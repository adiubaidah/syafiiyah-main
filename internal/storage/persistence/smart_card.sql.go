// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: smart_card.sql

package persistence

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSmartCards = `-- name: CountSmartCards :one
SELECT
    COUNT(*) as "count"
FROM
    smart_card
    LEFT JOIN "santri" ON "smart_card"."santri_id" = "santri"."id"
    LEFT JOIN "employee" ON "smart_card"."employee_id" = "employee"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "uid" ILIKE '%' || $1 || '%'
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "employee"."name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2::boolean IS NULL
        OR "smart_card"."is_active" = $2
    )
    AND (
        CASE
            WHEN $3::card_owner = 'santri' THEN "smart_card"."santri_id" IS NOT NULL
            WHEN $3::card_owner = 'employee' THEN "smart_card"."employee_id" IS NOT NULL
            WHEN $3::card_owner = 'all' THEN "smart_card"."santri_id" IS NOT NULL OR "smart_card"."employee_id" IS NOT NULL
            WHEN $3::card_owner = 'none' THEN "smart_card"."santri_id" IS NULL AND "smart_card"."employee_id" IS NULL
            ELSE TRUE
        END
    )
`

type CountSmartCardsParams struct {
	Q         pgtype.Text   `db:"q"`
	IsActive  pgtype.Bool   `db:"is_active"`
	CardOwner NullCardOwner `db:"card_owner"`
}

func (q *Queries) CountSmartCards(ctx context.Context, arg CountSmartCardsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSmartCards, arg.Q, arg.IsActive, arg.CardOwner)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSmartCard = `-- name: CreateSmartCard :one
INSERT INTO
    smart_card ("uid", "is_active", "santri_id", "employee_id")
VALUES
    (
        $1,
        $2,
        $3,
        $4
    ) RETURNING id, uid, created_at, is_active, santri_id, employee_id
`

type CreateSmartCardParams struct {
	Uid        string      `db:"uid"`
	IsActive   bool        `db:"is_active"`
	SantriID   pgtype.Int4 `db:"santri_id"`
	EmployeeID pgtype.Int4 `db:"employee_id"`
}

func (q *Queries) CreateSmartCard(ctx context.Context, arg CreateSmartCardParams) (SmartCard, error) {
	row := q.db.QueryRow(ctx, createSmartCard,
		arg.Uid,
		arg.IsActive,
		arg.SantriID,
		arg.EmployeeID,
	)
	var i SmartCard
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
	)
	return i, err
}

const deleteSmartCard = `-- name: DeleteSmartCard :one
DELETE FROM
    smart_card
WHERE
    "id" = $1 RETURNING id, uid, created_at, is_active, santri_id, employee_id
`

func (q *Queries) DeleteSmartCard(ctx context.Context, id int32) (SmartCard, error) {
	row := q.db.QueryRow(ctx, deleteSmartCard, id)
	var i SmartCard
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
	)
	return i, err
}

const getSmartCard = `-- name: GetSmartCard :one
SELECT
    smart_card.id, smart_card.uid, smart_card.created_at, smart_card.is_active, smart_card.santri_id, smart_card.employee_id,
    "santri"."name" as "santri_name",
    "employee"."name" as "employee_name"
FROM
    smart_card
    LEFT JOIN "santri" ON "smart_card"."santri_id" = "santri"."id"
    LEFT JOIN "employee" ON "smart_card"."employee_id" = "employee"."id"
WHERE
    "smart_card"."uid" = $1
`

type GetSmartCardRow struct {
	ID           int32              `db:"id"`
	Uid          string             `db:"uid"`
	CreatedAt    pgtype.Timestamptz `db:"created_at"`
	IsActive     bool               `db:"is_active"`
	SantriID     pgtype.Int4        `db:"santri_id"`
	EmployeeID   pgtype.Int4        `db:"employee_id"`
	SantriName   pgtype.Text        `db:"santri_name"`
	EmployeeName pgtype.Text        `db:"employee_name"`
}

func (q *Queries) GetSmartCard(ctx context.Context, uid string) (GetSmartCardRow, error) {
	row := q.db.QueryRow(ctx, getSmartCard, uid)
	var i GetSmartCardRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
		&i.SantriName,
		&i.EmployeeName,
	)
	return i, err
}

const listSmartCards = `-- name: ListSmartCards :many
SELECT
    smart_card.id, smart_card.uid, smart_card.created_at, smart_card.is_active, smart_card.santri_id, smart_card.employee_id,
    "santri"."name" AS "santri_name",
    "employee"."name" AS "employee_name"
FROM
    smart_card
    LEFT JOIN "santri" ON "smart_card"."santri_id" = "santri"."id"
    LEFT JOIN "employee" ON "smart_card"."employee_id" = "employee"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "uid" ILIKE '%' || $1 || '%'
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "employee"."name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2::boolean IS NULL
        OR "smart_card"."is_active" = $2
    )
    AND (
        CASE
            WHEN $3::card_owner = 'santri' THEN "smart_card"."santri_id" IS NOT NULL
            WHEN $3::card_owner = 'employee' THEN "smart_card"."employee_id" IS NOT NULL
            WHEN $3::card_owner = 'all' THEN "smart_card"."santri_id" IS NOT NULL OR "smart_card"."employee_id" IS NOT NULL
            WHEN $3::card_owner = 'none' THEN "smart_card"."santri_id" IS NULL AND "smart_card"."employee_id" IS NULL
            ELSE TRUE
        END
    )
ORDER BY
    "smart_card"."id" ASC
LIMIT
    $5 OFFSET $4
`

type ListSmartCardsParams struct {
	Q            pgtype.Text   `db:"q"`
	IsActive     pgtype.Bool   `db:"is_active"`
	CardOwner    NullCardOwner `db:"card_owner"`
	OffsetNumber int32         `db:"offset_number"`
	LimitNumber  int32         `db:"limit_number"`
}

type ListSmartCardsRow struct {
	ID           int32              `db:"id"`
	Uid          string             `db:"uid"`
	CreatedAt    pgtype.Timestamptz `db:"created_at"`
	IsActive     bool               `db:"is_active"`
	SantriID     pgtype.Int4        `db:"santri_id"`
	EmployeeID   pgtype.Int4        `db:"employee_id"`
	SantriName   pgtype.Text        `db:"santri_name"`
	EmployeeName pgtype.Text        `db:"employee_name"`
}

func (q *Queries) ListSmartCards(ctx context.Context, arg ListSmartCardsParams) ([]ListSmartCardsRow, error) {
	rows, err := q.db.Query(ctx, listSmartCards,
		arg.Q,
		arg.IsActive,
		arg.CardOwner,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSmartCardsRow{}
	for rows.Next() {
		var i ListSmartCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.CreatedAt,
			&i.IsActive,
			&i.SantriID,
			&i.EmployeeID,
			&i.SantriName,
			&i.EmployeeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSmartCard = `-- name: UpdateSmartCard :one
UPDATE
    smart_card
SET
    "uid" = COALESCE($1, uid),
    "is_active" = COALESCE($2, is_active),
    "santri_id" = $3,
    "employee_id" = $4
WHERE
    "id" = $5 RETURNING id, uid, created_at, is_active, santri_id, employee_id
`

type UpdateSmartCardParams struct {
	Uid        pgtype.Text `db:"uid"`
	IsActive   pgtype.Bool `db:"is_active"`
	SantriID   pgtype.Int4 `db:"santri_id"`
	EmployeeID pgtype.Int4 `db:"employee_id"`
	ID         int32       `db:"id"`
}

func (q *Queries) UpdateSmartCard(ctx context.Context, arg UpdateSmartCardParams) (SmartCard, error) {
	row := q.db.QueryRow(ctx, updateSmartCard,
		arg.Uid,
		arg.IsActive,
		arg.SantriID,
		arg.EmployeeID,
		arg.ID,
	)
	var i SmartCard
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
	)
	return i, err
}
