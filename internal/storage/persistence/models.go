// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package persistence

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type CardOwner string

const (
	CardOwnerSantri   CardOwner = "santri"
	CardOwnerEmployee CardOwner = "employee"
	CardOwnerAll      CardOwner = "all"
	CardOwnerNone     CardOwner = "none"
)

func (e *CardOwner) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CardOwner(s)
	case string:
		*e = CardOwner(s)
	default:
		return fmt.Errorf("unsupported scan type for CardOwner: %T", src)
	}
	return nil
}

type NullCardOwner struct {
	CardOwner CardOwner
	Valid     bool // Valid is true if CardOwner is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCardOwner) Scan(value interface{}) error {
	if value == nil {
		ns.CardOwner, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CardOwner.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCardOwner) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CardOwner), nil
}

type DeviceModeType string

const (
	DeviceModeTypeRecord     DeviceModeType = "record"
	DeviceModeTypePresence   DeviceModeType = "presence"
	DeviceModeTypePermission DeviceModeType = "permission"
	DeviceModeTypePing       DeviceModeType = "ping"
)

func (e *DeviceModeType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DeviceModeType(s)
	case string:
		*e = DeviceModeType(s)
	default:
		return fmt.Errorf("unsupported scan type for DeviceModeType: %T", src)
	}
	return nil
}

type NullDeviceModeType struct {
	DeviceModeType DeviceModeType
	Valid          bool // Valid is true if DeviceModeType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDeviceModeType) Scan(value interface{}) error {
	if value == nil {
		ns.DeviceModeType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DeviceModeType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDeviceModeType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DeviceModeType), nil
}

type GenderType string

const (
	GenderTypeMale   GenderType = "male"
	GenderTypeFemale GenderType = "female"
)

func (e *GenderType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GenderType(s)
	case string:
		*e = GenderType(s)
	default:
		return fmt.Errorf("unsupported scan type for GenderType: %T", src)
	}
	return nil
}

type NullGenderType struct {
	GenderType GenderType
	Valid      bool // Valid is true if GenderType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGenderType) Scan(value interface{}) error {
	if value == nil {
		ns.GenderType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GenderType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGenderType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GenderType), nil
}

type ParentOrderBy string

const (
	ParentOrderByAscName  ParentOrderBy = "asc:name"
	ParentOrderByDescName ParentOrderBy = "desc:name"
)

func (e *ParentOrderBy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParentOrderBy(s)
	case string:
		*e = ParentOrderBy(s)
	default:
		return fmt.Errorf("unsupported scan type for ParentOrderBy: %T", src)
	}
	return nil
}

type NullParentOrderBy struct {
	ParentOrderBy ParentOrderBy
	Valid         bool // Valid is true if ParentOrderBy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParentOrderBy) Scan(value interface{}) error {
	if value == nil {
		ns.ParentOrderBy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParentOrderBy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParentOrderBy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParentOrderBy), nil
}

type PresenceCreatedByType string

const (
	PresenceCreatedByTypeSystem PresenceCreatedByType = "system"
	PresenceCreatedByTypeTap    PresenceCreatedByType = "tap"
	PresenceCreatedByTypeAdmin  PresenceCreatedByType = "admin"
)

func (e *PresenceCreatedByType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PresenceCreatedByType(s)
	case string:
		*e = PresenceCreatedByType(s)
	default:
		return fmt.Errorf("unsupported scan type for PresenceCreatedByType: %T", src)
	}
	return nil
}

type NullPresenceCreatedByType struct {
	PresenceCreatedByType PresenceCreatedByType
	Valid                 bool // Valid is true if PresenceCreatedByType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPresenceCreatedByType) Scan(value interface{}) error {
	if value == nil {
		ns.PresenceCreatedByType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PresenceCreatedByType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPresenceCreatedByType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PresenceCreatedByType), nil
}

type PresenceType string

const (
	PresenceTypeAlpha      PresenceType = "alpha"
	PresenceTypePermission PresenceType = "permission"
	PresenceTypeSick       PresenceType = "sick"
	PresenceTypeLate       PresenceType = "late"
	PresenceTypePresent    PresenceType = "present"
)

func (e *PresenceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PresenceType(s)
	case string:
		*e = PresenceType(s)
	default:
		return fmt.Errorf("unsupported scan type for PresenceType: %T", src)
	}
	return nil
}

type NullPresenceType struct {
	PresenceType PresenceType
	Valid        bool // Valid is true if PresenceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPresenceType) Scan(value interface{}) error {
	if value == nil {
		ns.PresenceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PresenceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPresenceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PresenceType), nil
}

type RoleType string

const (
	RoleTypeSuperadmin RoleType = "superadmin"
	RoleTypeAdmin      RoleType = "admin"
	RoleTypeEmployee   RoleType = "employee"
	RoleTypeParent     RoleType = "parent"
	RoleTypeSantri     RoleType = "santri"
)

func (e *RoleType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RoleType(s)
	case string:
		*e = RoleType(s)
	default:
		return fmt.Errorf("unsupported scan type for RoleType: %T", src)
	}
	return nil
}

type NullRoleType struct {
	RoleType RoleType
	Valid    bool // Valid is true if RoleType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRoleType) Scan(value interface{}) error {
	if value == nil {
		ns.RoleType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RoleType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRoleType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RoleType), nil
}

type SantriOrderBy string

const (
	SantriOrderByAscName        SantriOrderBy = "asc:name"
	SantriOrderByAscNis         SantriOrderBy = "asc:nis"
	SantriOrderByAscGeneration  SantriOrderBy = "asc:generation"
	SantriOrderByDescName       SantriOrderBy = "desc:name"
	SantriOrderByDescNis        SantriOrderBy = "desc:nis"
	SantriOrderByDescGeneration SantriOrderBy = "desc:generation"
)

func (e *SantriOrderBy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SantriOrderBy(s)
	case string:
		*e = SantriOrderBy(s)
	default:
		return fmt.Errorf("unsupported scan type for SantriOrderBy: %T", src)
	}
	return nil
}

type NullSantriOrderBy struct {
	SantriOrderBy SantriOrderBy
	Valid         bool // Valid is true if SantriOrderBy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSantriOrderBy) Scan(value interface{}) error {
	if value == nil {
		ns.SantriOrderBy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SantriOrderBy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSantriOrderBy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SantriOrderBy), nil
}

type SantriPermissionType string

const (
	SantriPermissionTypeSick       SantriPermissionType = "sick"
	SantriPermissionTypePermission SantriPermissionType = "permission"
)

func (e *SantriPermissionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SantriPermissionType(s)
	case string:
		*e = SantriPermissionType(s)
	default:
		return fmt.Errorf("unsupported scan type for SantriPermissionType: %T", src)
	}
	return nil
}

type NullSantriPermissionType struct {
	SantriPermissionType SantriPermissionType
	Valid                bool // Valid is true if SantriPermissionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSantriPermissionType) Scan(value interface{}) error {
	if value == nil {
		ns.SantriPermissionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SantriPermissionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSantriPermissionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SantriPermissionType), nil
}

type UserOrderBy string

const (
	UserOrderByAscUsername  UserOrderBy = "asc:username"
	UserOrderByDescUsername UserOrderBy = "desc:username"
	UserOrderByAscName      UserOrderBy = "asc:name"
	UserOrderByDescName     UserOrderBy = "desc:name"
)

func (e *UserOrderBy) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserOrderBy(s)
	case string:
		*e = UserOrderBy(s)
	default:
		return fmt.Errorf("unsupported scan type for UserOrderBy: %T", src)
	}
	return nil
}

type NullUserOrderBy struct {
	UserOrderBy UserOrderBy
	Valid       bool // Valid is true if UserOrderBy is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserOrderBy) Scan(value interface{}) error {
	if value == nil {
		ns.UserOrderBy, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserOrderBy.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserOrderBy) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserOrderBy), nil
}

type AdminRestriction struct {
	ID                   int32 `db:"id"`
	AdminID              int32 `db:"admin_id"`
	RestrictedEmployeeID int32 `db:"restricted_employee_id"`
}

type Device struct {
	ID int32 `db:"id"`
	// ex: device1
	Name string `db:"name"`
}

type DeviceMode struct {
	ID   int32          `db:"id"`
	Mode DeviceModeType `db:"mode"`
	// topic for input
	InputTopic string `db:"input_topic"`
	// topic for acknowledgment
	AcknowledgmentTopic string `db:"acknowledgment_topic"`
	DeviceID            int32  `db:"device_id"`
}

type Employee struct {
	ID           int32       `db:"id"`
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       GenderType  `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
}

type EmployeeOccupation struct {
	ID          int32       `db:"id"`
	Name        string      `db:"name"`
	Description pgtype.Text `db:"description"`
}

type EmployeePermission struct {
	ID              int32       `db:"id"`
	EmployeeID      int32       `db:"employee_id"`
	ScheduleID      int32       `db:"schedule_id"`
	ScheduleName    string      `db:"schedule_name"`
	StartPermission pgtype.Time `db:"start_permission"`
	// waktu kembali, null berarti pulang
	EndPermission pgtype.Time `db:"end_permission"`
	Reason        string      `db:"reason"`
	// Pulang, keluar sementara
	IsGoHome pgtype.Bool `db:"is_go_home"`
}

type EmployeePresence struct {
	ID         pgtype.Int4  `db:"id"`
	ScheduleID pgtype.Int4  `db:"schedule_id"`
	Type       PresenceType `db:"type"`
	EmployeeID int32        `db:"employee_id"`
	Notes      pgtype.Text  `db:"notes"`
}

type EmployeeSchedule struct {
	ID int32 `db:"id"`
	// ex: Pagi, siang, sore, malam
	Name          string      `db:"name"`
	StartPresence pgtype.Time `db:"start_presence"`
	// Waktu jenis
	StartTime  pgtype.Time `db:"start_time"`
	FinishTime pgtype.Time `db:"finish_time"`
}

type Holiday struct {
	ID int32 `db:"id"`
	// Optional description of the holiday
	Name        string      `db:"name"`
	Color       pgtype.Text `db:"color"`
	Description pgtype.Text `db:"description"`
}

type HolidayDate struct {
	ID        int32       `db:"id"`
	Date      pgtype.Date `db:"date"`
	HolidayID int32       `db:"holiday_id"`
}

type Parent struct {
	ID             int32       `db:"id"`
	Name           string      `db:"name"`
	Address        string      `db:"address"`
	Gender         GenderType  `db:"gender"`
	WhatsappNumber pgtype.Text `db:"whatsapp_number"`
	Photo          pgtype.Text `db:"photo"`
	UserID         pgtype.Int4 `db:"user_id"`
}

type Santri struct {
	ID     int32       `db:"id"`
	Nis    pgtype.Text `db:"nis"`
	Name   string      `db:"name"`
	Gender GenderType  `db:"gender"`
	// ex: 2024, 2022
	Generation   int32       `db:"generation"`
	IsActive     pgtype.Bool `db:"is_active"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID pgtype.Int4 `db:"occupation_id"`
	ParentID     pgtype.Int4 `db:"parent_id"`
}

type SantriOccupation struct {
	ID          int32       `db:"id"`
	Name        string      `db:"name"`
	Description pgtype.Text `db:"description"`
}

type SantriPermission struct {
	ID              int32                `db:"id"`
	SantriID        int32                `db:"santri_id"`
	Type            SantriPermissionType `db:"type"`
	StartPermission pgtype.Timestamptz   `db:"start_permission"`
	// Waktu berakhir, jika pulang, maka setting end permissionnya di akhir waktu berakhirnya schedule yang terakhir
	EndPermission pgtype.Timestamptz `db:"end_permission"`
	Excuse        string             `db:"excuse"`
}

type SantriPresence struct {
	ID int32 `db:"id"`
	// Karena bisa saja activitynya dihapus
	ScheduleID int32 `db:"schedule_id"`
	// menggunakan name, karena jika activity dihapus, atau diubah maka masih tetap ada presence nya, karena bersifat history
	ScheduleName string                `db:"schedule_name"`
	Type         PresenceType          `db:"type"`
	SantriID     int32                 `db:"santri_id"`
	CreatedAt    pgtype.Timestamptz    `db:"created_at"`
	CreatedBy    PresenceCreatedByType `db:"created_by"`
	Notes        pgtype.Text           `db:"notes"`
	// Jika izin ditengah kegiatan maka akan diisi
	SantriPermissionID pgtype.Int4 `db:"santri_permission_id"`
	CreatedDate        pgtype.Date `db:"created_date"`
}

type SantriSchedule struct {
	ID            int32       `db:"id"`
	Name          string      `db:"name"`
	Description   pgtype.Text `db:"description"`
	StartPresence pgtype.Time `db:"start_presence"`
	// Waktu mulai kegiatan
	StartTime pgtype.Time `db:"start_time"`
	// Waktu berakhirnya kegiatan
	FinishTime pgtype.Time `db:"finish_time"`
}

type SmartCard struct {
	ID        int32              `db:"id"`
	Uid       string             `db:"uid"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	IsActive  bool               `db:"is_active"`
	// Smart Card bisa milik santri
	SantriID pgtype.Int4 `db:"santri_id"`
	// Smart Card bisa milik employee
	EmployeeID pgtype.Int4 `db:"employee_id"`
}

type User struct {
	ID       int32        `db:"id"`
	Role     NullRoleType `db:"role"`
	Username pgtype.Text  `db:"username"`
	Password pgtype.Text  `db:"password"`
}
