// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: employee.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEmployees = `-- name: CountEmployees :one

SELECT
    COUNT(*)
FROM
    employee
    LEFT JOIN "user" ON employee.user_id = "user".id
    LEFT JOIN employee_occupation ON employee.occupation_id = employee_occupation.id
WHERE
    (
        $1::text IS NULL
        OR employee.name ILIKE '%%' || $1::text || '%%'
        OR employee.nip ILIKE '%%' || $1::text || '%%'
    )
    AND (
        $2::int IS NULL
        OR employee.occupation_id = $2::int
    )
    AND (
        $3::boolean IS NULL
        OR (
            $3::boolean = TRUE
            AND "user".id IS NOT NULL
        )
        OR (
            $3::boolean = FALSE
            AND "user".id IS NULL
        )
    )
`

type CountEmployeesParams struct {
	Q            pgtype.Text `db:"q"`
	OccupationID pgtype.Int4 `db:"occupation_id"`
	HasUser      pgtype.Bool `db:"has_user"`
}

func (q *Queries) CountEmployees(ctx context.Context, arg CountEmployeesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEmployees, arg.Q, arg.OccupationID, arg.HasUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO
    "employee" (
        "nip",
        "name",
        "gender",
        "photo",
        "occupation_id",
        "user_id"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4 :: text,
        $5,
        $6 :: integer
    ) RETURNING id, nip, name, gender, photo, occupation_id, user_id
`

type CreateEmployeeParams struct {
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       GenderType  `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.Nip,
		arg.Name,
		arg.Gender,
		arg.Photo,
		arg.OccupationID,
		arg.UserID,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :one
DELETE FROM
    "employee"
WHERE
    "id" = $1 RETURNING id, nip, name, gender, photo, occupation_id, user_id
`

func (q *Queries) DeleteEmployee(ctx context.Context, id int32) (Employee, error) {
	row := q.db.QueryRow(ctx, deleteEmployee, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT
    employee.id, employee.nip, employee.name, employee.gender, employee.photo, employee.occupation_id, employee.user_id,
    "user"."id" AS "userId",
    "user"."username" AS "userUsername"
FROM
    "employee"
    LEFT JOIN "user" ON "employee"."user_id" = "user"."id"
WHERE
    "employee"."id" = $1
`

type GetEmployeeByIDRow struct {
	ID           int32       `db:"id"`
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       GenderType  `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
	UserId       pgtype.Int4 `db:"userId"`
	UserUsername pgtype.Text `db:"userUsername"`
}

func (q *Queries) GetEmployeeByID(ctx context.Context, id int32) (GetEmployeeByIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeByID, id)
	var i GetEmployeeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
		&i.UserId,
		&i.UserUsername,
	)
	return i, err
}

const getEmployeeByUserID = `-- name: GetEmployeeByUserID :one
SELECT
    employee.id, employee.nip, employee.name, employee.gender, employee.photo, employee.occupation_id, employee.user_id
FROM
    "employee"
WHERE
    "user_id" = $1
`

func (q *Queries) GetEmployeeByUserID(ctx context.Context, userID pgtype.Int4) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeeByUserID, userID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE
    "employee"
SET
    "nip" = $1,
    "name" = COALESCE($2, name),
    "gender" = COALESCE($3 :: gender_type, gender),
    "photo" = $4,
    "occupation_id" = COALESCE($5, occupation_id),
    "user_id" = $6
WHERE
    "id" = $7 RETURNING id, nip, name, gender, photo, occupation_id, user_id
`

type UpdateEmployeeParams struct {
	Nip          pgtype.Text    `db:"nip"`
	Name         pgtype.Text    `db:"name"`
	Gender       NullGenderType `db:"gender"`
	Photo        pgtype.Text    `db:"photo"`
	OccupationID pgtype.Int4    `db:"occupation_id"`
	UserID       pgtype.Int4    `db:"user_id"`
	ID           int32          `db:"id"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.Nip,
		arg.Name,
		arg.Gender,
		arg.Photo,
		arg.OccupationID,
		arg.UserID,
		arg.ID,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}
